"use strict";
/* istanbul ignore file */
/* We ignore this file because OAuth endpoints are too taxing to test, they are instead manually tested. */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const constants_1 = require("./constants");
const services_1 = require("./services");
const util_1 = require("./util");
/**
 * All methods requiring an OAuth access token.
 * Use `YouTube#oauth` to access these methods.
 */
class OAuth {
    /**
     *
     * @param youtube The YouTube object to retrieve the token from.
     */
    constructor(youtube) {
        this.youtube = youtube;
    }
    /**
     * @ignore
     */
    checkTokenAndThrow() {
        if (!this.youtube.accessToken) {
            throw new Error('Must have an access token for OAuth related methods');
        }
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Gets the authorized user's [[Channel]].
     * Last tested 03/06/2020 22:21. PASSING
     */
    // tslint:enable:no-trailing-whitespace
    getMe() {
        this.checkTokenAndThrow();
        return services_1.GenericService.getItem(this.youtube, _1.Channel, true);
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Gets the authorized user's [[Subscription]]s.
     * Last tested 03/06/2020 23:20. PASSING
     * @param maxResults The maximum number of subscriptions to fetch.
     * Fetches 10 by default. Set to a value <=0 to fetch all.
     */
    // tslint:enable:no-trailing-whitespace
    getMySubscriptions(maxResults = 10) {
        this.checkTokenAndThrow();
        return services_1.GenericService.getPaginatedItems(this.youtube, 'subscriptions', true, null, maxResults);
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Gets the authorized user's [[Playlist]]s.
     * Last tested 03/06/2020 23:23. PASSING
     * @param maxResults The maximum number of playlists to fetch.
     * Fetches 10 by default. Set to a value <=0 to fetch all.
     */
    // tslint:enable:no-trailing-whitespace
    getMyPlaylists(maxResults = 10) {
        this.checkTokenAndThrow();
        return services_1.GenericService.getPaginatedItems(this.youtube, 'playlists:channel', true, null, maxResults);
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Post a [[Comment]] on a [[Video]] or [[Channel]] discussion.
     * Last tested 03/04/2020 23:20. PASSING
     * @param text The text content of the comment.
     * @param channelId The channel to post the comment on.
     * @param videoId The video of the channel to post the comment on.
     * If falsey, the comment will be posted to the channel discussion.
     */
    // tslint:enable:no-trailing-whitespace
    postComment(text, channelId, videoId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.CommentThreadData));
            data.snippet.topLevelComment.snippet.textOriginal = text;
            data.snippet.channelId = channelId;
            if (videoId) {
                data.snippet.videoId = videoId;
            }
            const result = yield this.youtube._request.post('commentThreads', { part: 'snippet' }, JSON.stringify(data), null, this.youtube.accessToken);
            const type = result.snippet.channelId ? 'channel' : 'video';
            return new _1.YTComment(this.youtube, result.snippet.topLevelComment, type);
        });
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Edit a [[Comment]] on a [[Video]] or [[Channel]] discussion.
     * Last tested 03/04/2020 23:20. PASSING
     * @param text The new text content of the comment.
     * @param commentId The ID of the comment.
     */
    // tslint:enable:no-trailing-whitespace
    editComment(text, commentId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.CommentThreadData));
            data.snippet.topLevelComment.snippet.textOriginal = text;
            data.id = commentId;
            const result = yield this.youtube._request.put('commentThreads', { part: 'snippet' }, JSON.stringify(data), null, this.youtube.accessToken);
            const type = result.snippet.channelId ? 'channel' : 'video';
            const comment = new _1.YTComment(this.youtube, result.snippet.topLevelComment, type);
            if (result.replies) {
                result.replies.comments.forEach(reply => {
                    const created = new _1.YTComment(this.youtube, reply, type);
                    comment.replies.push(created);
                });
            }
            return comment;
        });
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Subscribe to a [[Channel]].
     * Last tested 03/04/2020 23:17. PASSING
     * @param channelId The channel to subscribe to.
     * @returns A partial subscription object.
     */
    // tslint:enable:no-trailing-whitespace
    subscribeToChannel(channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.SubscriptionData));
            data.snippet.resourceId.channelId = channelId;
            const result = yield this.youtube._request.post('subscriptions', { part: 'snippet' }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Subscription(this.youtube, result);
        });
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Unsubscribe from a [[Channel]].
     * Last tested 03/04/2020 23:17. PASSING
     * @param channelId The channel to unsubscribe from.
     */
    // tslint:enable:no-trailing-whitespace
    unsubscribeFromChannel(subscriptionId) {
        this.checkTokenAndThrow();
        return this.youtube._request.delete('subscriptions', { id: subscriptionId }, null, this.youtube.accessToken);
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Like, dislike, or remove a rating from a [[Video]].
     * Last tested 03/07/2020 02:15. PASSING
     * @param videoId The video to rate.
     * @param rating The rating to give the video.
     */
    // tslint:enable:no-trailing-whitespace
    rateVideo(videoId, rating) {
        this.checkTokenAndThrow();
        return this.youtube._request.post('videos/rate', { id: videoId, rating }, null, null, this.youtube.accessToken);
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Retrieve your rating on a [[Video]].
     * Last tested 03/07/2020 02:35. PASSING
     * @param videoId The video to retrieve your rating from.
     */
    // tslint:enable:no-trailing-whitespace
    getMyRatings(videoIds) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const cached = util_1.Cache.get(`get://videos/getRating/${JSON.stringify(videoIds)}`);
            if (this.youtube._shouldCache && cached) {
                return cached;
            }
            const response = yield this.youtube._request.api('videos/getRating', { id: videoIds.join(',') }, null, this.youtube.accessToken);
            this.youtube._cache(`get://videos/getRating/${JSON.stringify(videoIds)}`, response.items);
            return response.items;
        });
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Report a [[Video]] for abuse.
     * Last tested NEVER
     * @param videoId The video to report.
     * @param reasonId The reason for reporting. (IDs can be found [here](https://developers.google.com/youtube/v3/docs/videoAbuseReportReasons/list))
     * @param secondaryReasonId An optional second reason for reporting.
     * @param comments Any additional information.
     * @param language The language that the reporter speaks.
     */
    // tslint:enable:no-trailing-whitespace
    reportAbuse(videoId, reasonId, secondaryReasonId, comments, language) {
        this.checkTokenAndThrow();
        const data = {
            videoId,
            reasonId
        };
        if (secondaryReasonId)
            data.secondaryReasonId = secondaryReasonId;
        if (comments)
            data.comments = comments;
        if (language)
            data.language = language;
        return this.youtube._request.post('videos/reportAbuse', null, JSON.stringify(data), null, this.youtube.accessToken);
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Deletes a [[Video]].
     * Last tested NEVER
     * @param videoId The video to delete.
     */
    // tslint:enable:no-trailing-whitespace
    deleteVideo(videoId) {
        this.checkTokenAndThrow();
        return this.youtube._request.delete('videos', { id: videoId }, null, this.youtube.accessToken);
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Updates a [[Video]].
     * **If your request does not specify a value for a property that already has a value,
     * the property's existing value will be deleted.**
     * Last tested NEVER
     * @param video The updated video object.
     */
    // tslint:enable:no-trailing-whitespace
    updateVideo(video) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const parts = [];
            if (video.snippet) {
                parts.push('snippet');
                if (Array.isArray(video.snippet.tags))
                    video.snippet.tags = video.snippet.tags.join(',');
            }
            if (video.status) {
                parts.push('status');
                if (video.status.publishAt instanceof Date)
                    video.status.publishAt = video.status.publishAt.toISOString();
            }
            if (video.recordingDetails) {
                parts.push('recordingDetails');
                if (video.recordingDetails.recordingDate instanceof Date) {
                    video.recordingDetails.recordingDate = video.recordingDetails.recordingDate.toISOString();
                }
            }
            if (video.localizations)
                parts.push('localizations');
            if (parts.length === 0) {
                return this.youtube.getVideo(video.id);
            }
            const response = yield this.youtube._request.put('videos', { part: parts.join(',') }, JSON.stringify(video), null, this.youtube.accessToken);
            return new _1.Video(this.youtube, response);
        });
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Sets a new [[Thumbnail]] for a [[Video]].
     * Last tested 03/07/2020 11:25. PASSING
     * @param videoId The video to set the thumbnail for.
     * @param image The image data and type to upload.
     */
    // tslint:enable:no-trailing-whitespace
    setThumbnail(videoId, image) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const response = yield this.youtube._upload.imagePost('thumbnails/set', image.data, image.type, { videoId }, null, this.youtube.accessToken);
            return response.items[0];
        });
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Creates a [[Playlist]].
     * Last tested 03/19/2020 03:06. PASSING
     * @param title A title for the playlist.
     * @param description A description of the playlist.
     * @param privacy Whether the video is private, public, or unlisted.
     * @param tags Tags pertaining to the playlist.
     * @param language The language of the playlist's default title and description.
     * @param localizations Translated titles and descriptions.
     */
    // tslint:enable:no-trailing-whitespace
    createPlaylist(title, description, privacy, tags, language, localizations) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.PlaylistData));
            const parts = ['id', 'player'];
            data.snippet = { title };
            if (description)
                data.snippet.description = description;
            if (privacy)
                data.status = { privacyStatus: privacy };
            if (tags)
                data.snippet.tags = tags.join(',');
            if (language)
                data.snippet.defaultLanguage = language;
            if (localizations)
                data.localizations = localizations;
            if (description || tags || language)
                parts.push('snippet');
            if (privacy)
                parts.push('status');
            if (localizations)
                parts.push('localizations');
            const response = yield this.youtube._request.post('playlists', { part: parts.join(',') }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Playlist(this.youtube, response);
        });
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Updates a [[Playlist]].
     * **If your request does not specify a value for a property that already has a value,
     * the property's existing value will be deleted.**
     * Last tested 03/19/2020 03:13. PASSING
     * @param id The ID of the playlist to update.
     * @param title A title for the playlist.
     * @param description A description of the playlist.
     * @param privacy Whether the video is private, public, or unlisted.
     * @param tags Tags pertaining to the playlist.
     * @param language The language of the playlist's default title and description.
     * @param localizations Translated titles and descriptions.
     */
    // tslint:enable:no-trailing-whitespace
    updatePlaylist(id, title, description, privacy, tags, language, localizations) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.PlaylistData));
            const parts = ['id', 'player'];
            data.id = id;
            data.snippet = { title };
            if (description)
                data.snippet.description = description;
            if (privacy)
                data.status = { privacyStatus: privacy };
            if (tags)
                data.snippet.tags = tags.join(',');
            if (language)
                data.snippet.defaultLanguage = language;
            if (localizations)
                data.localizations = localizations;
            if (description || tags || language)
                parts.push('snippet');
            if (privacy)
                parts.push('status');
            if (localizations)
                parts.push('localizations');
            const response = yield this.youtube._request.put('playlists', { part: parts.join(',') }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Playlist(this.youtube, response);
        });
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Deletes a [[Playlist]].
     * Last tested 03/19/2020 03:18. PASSING
     * @param id The ID of the playlist to delete.
     */
    // tslint:enable:no-trailing-whitespace
    deletePlaylist(id) {
        this.checkTokenAndThrow();
        return this.youtube._request.delete('playlists', { id }, null, this.youtube.accessToken);
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Get a list of video abuse report reasons.
     * Last tested 03/14/2020 10:47. PASSING
     */
    // tslint:enable:no-trailing-whitespace
    getVideoAbuseReportReasons() {
        this.checkTokenAndThrow();
        return services_1.GenericService.getPaginatedItems(this.youtube, 'videoAbuseReportReasons', false);
    }
}
exports.OAuth = OAuth;

//# sourceMappingURL=oauth.js.map
